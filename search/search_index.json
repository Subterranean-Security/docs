{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sandpolis Official Documentation This site explains how to install , configure , and maintain Sandpolis. It also contains a high-level programming reference useful to developers. It's still a work in progress; feel free to open an issue . The Basics You may already be familiar with other remote-control applications that allow you to monitor/manage many different computers from a single pane of glass. To use these tools, you might install an agent on the computers you wish to manage and direct the agent to connect back to the main application running on your computer. While relatively simple, there are some major disadvantages to this approach: Your computer may not always be online to accept connections Your computer may not have a stable IP address This architecture does not scale as the number of agents increases To address these problems, Sandpolis uses a client-server-agent (CSA) architecture. Rather than connecting agents directly to an application on your computer, a central server mediates most interactions between you and your systems. Client <-> Server <-> Agent With CSA, clients and agents can come and go without affecting the rest of the network. This means that: background or scheduled tasks can continue after a user logs out; users are not restricted to a particular user interface; users don't have to adjust their firewalls or port-forwarding rules. CSA also comes with a few drawbacks: The server is just another application to maintain Although it can be easy to deploy with Docker, the server still requires some effort to maintain. In addition to the initial setup, it's important to periodically update the server and harden its security. The server is a high value attack target While the server is designed to be as resilient and secure as possible, it can't be perfect. If an attacker is able to compromise the server (or a user account with sufficiently high privileges), they effectively have full control over all systems connected to it. To help mitigate this risk, all Sandpolis user accounts are required to use two-factor authentication and password rotation. Messages between clients and agents are usually routed through the server first Often times the route between a user and their systems will be faster than the client/server route plus the server/agent route. This is especially true if a user is on the same network as their systems. To mitigate this issue, the server can automatically coordinate a direct connection between any two nodes for high-volume messages like remote desktop session or file transfers.","title":"Home"},{"location":"#sandpolis-official-documentation","text":"This site explains how to install , configure , and maintain Sandpolis. It also contains a high-level programming reference useful to developers. It's still a work in progress; feel free to open an issue .","title":"Sandpolis Official Documentation"},{"location":"#the-basics","text":"You may already be familiar with other remote-control applications that allow you to monitor/manage many different computers from a single pane of glass. To use these tools, you might install an agent on the computers you wish to manage and direct the agent to connect back to the main application running on your computer. While relatively simple, there are some major disadvantages to this approach: Your computer may not always be online to accept connections Your computer may not have a stable IP address This architecture does not scale as the number of agents increases To address these problems, Sandpolis uses a client-server-agent (CSA) architecture. Rather than connecting agents directly to an application on your computer, a central server mediates most interactions between you and your systems.","title":"The Basics"},{"location":"#client-server-agent","text":"With CSA, clients and agents can come and go without affecting the rest of the network. This means that: background or scheduled tasks can continue after a user logs out; users are not restricted to a particular user interface; users don't have to adjust their firewalls or port-forwarding rules. CSA also comes with a few drawbacks:","title":"Client &lt;-&gt; Server &lt;-&gt; Agent"},{"location":"#the-server-is-just-another-application-to-maintain","text":"Although it can be easy to deploy with Docker, the server still requires some effort to maintain. In addition to the initial setup, it's important to periodically update the server and harden its security.","title":"The server is just another application to maintain"},{"location":"#the-server-is-a-high-value-attack-target","text":"While the server is designed to be as resilient and secure as possible, it can't be perfect. If an attacker is able to compromise the server (or a user account with sufficiently high privileges), they effectively have full control over all systems connected to it. To help mitigate this risk, all Sandpolis user accounts are required to use two-factor authentication and password rotation.","title":"The server is a high value attack target"},{"location":"#messages-between-clients-and-agents-are-usually-routed-through-the-server-first","text":"Often times the route between a user and their systems will be faster than the client/server route plus the server/agent route. This is especially true if a user is on the same network as their systems. To mitigate this issue, the server can automatically coordinate a direct connection between any two nodes for high-volume messages like remote desktop session or file transfers.","title":"Messages between clients and agents are usually routed through the server first"},{"location":"application/agent/","text":"1 Agent Agent installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of a server or client installation. 1.1 Filesystem Structure /base/agent.jar The agent executable, named according to the configuration. /base/agent.db The agent's only database, named according to the executable. /base/lib A directory for extracted agent-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory. 1.2 Additional Changes The agent-installer makes additional platform specific changes upon installation: 1.2.1 Windows 1.2.2 Linux 1.2.3 Mac OS 1.3 Upgrading There are two ways to upgrade the agent: - automatically by sending the update command to the server, - manually by generating a new installer and executing it on the agent 1.3.1 Manual Upgrade A manual upgrade is triggered when an installer is executed on the agent and the relevant base directory is already populated with an installation. If the agent is not running, the installer will overwrite the base directory and install itself. Any data that the agent has cached but not sent to the server will be lost! Advantages - This is the only way to upgrade if the agent can no longer connect to the server Disadvantages - Manual intervention required - Cached data may be lost 1.3.2 Automated Upgrade If the agent is connected to a server, simply issue the update/upgrade command from a viewer instance. This will cause the server to fetch the agent configuration, generate a new installer, and transfer it to the agent. The agent then executes the new installer and terminates.","title":"Agent"},{"location":"application/agent/#1-agent","text":"Agent installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of a server or client installation.","title":"1 Agent"},{"location":"application/agent/#11-filesystem-structure","text":"/base/agent.jar The agent executable, named according to the configuration. /base/agent.db The agent's only database, named according to the executable. /base/lib A directory for extracted agent-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory.","title":"1.1 Filesystem Structure"},{"location":"application/agent/#12-additional-changes","text":"The agent-installer makes additional platform specific changes upon installation:","title":"1.2 Additional Changes"},{"location":"application/agent/#121-windows","text":"","title":"1.2.1 Windows"},{"location":"application/agent/#122-linux","text":"","title":"1.2.2 Linux"},{"location":"application/agent/#123-mac-os","text":"","title":"1.2.3 Mac OS"},{"location":"application/agent/#13-upgrading","text":"There are two ways to upgrade the agent: - automatically by sending the update command to the server, - manually by generating a new installer and executing it on the agent","title":"1.3 Upgrading"},{"location":"application/agent/#131-manual-upgrade","text":"A manual upgrade is triggered when an installer is executed on the agent and the relevant base directory is already populated with an installation. If the agent is not running, the installer will overwrite the base directory and install itself. Any data that the agent has cached but not sent to the server will be lost! Advantages - This is the only way to upgrade if the agent can no longer connect to the server Disadvantages - Manual intervention required - Cached data may be lost","title":"1.3.1 Manual Upgrade"},{"location":"application/agent/#132-automated-upgrade","text":"If the agent is connected to a server, simply issue the update/upgrade command from a viewer instance. This will cause the server to fetch the agent configuration, generate a new installer, and transfer it to the agent. The agent then executes the new installer and terminates.","title":"1.3.2 Automated Upgrade"},{"location":"application/client/","text":"3 Client Client installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of an agent or server installation. 3.1 Filesystem Structure /base/client.jar The client executable. /base/client.ico An icon for the client /base/db A directory for client databases. Each server that the client connects to will have a corresponding database located here. /base/lib A directory for extracted client-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory. 3.2 Additional Changes The client-installer makes additional platform specific changes upon installation: 3.2.1 Windows 3.2.2 Linux 3.2.3 Mac OS Installer Flags Property Default Description path user.home + /.sandpolis The base installation path components null The components to install version latest The version to install ext.linux.desktop /usr/share/applications; user.home + /.local/share/applications The Linux desktop entry location ext.windows.start C:/ProgramData/Microsoft/Windows/Start Menu/Programs; user.home + /AppData/Microsoft/Windows/Start Menu/Programs The Windows start menu location ext.windows.desktop user.home + /Desktop The Windows desktop shortcut location","title":"Client"},{"location":"application/client/#3-client","text":"Client installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of an agent or server installation.","title":"3 Client"},{"location":"application/client/#31-filesystem-structure","text":"/base/client.jar The client executable. /base/client.ico An icon for the client /base/db A directory for client databases. Each server that the client connects to will have a corresponding database located here. /base/lib A directory for extracted client-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory.","title":"3.1 Filesystem Structure"},{"location":"application/client/#32-additional-changes","text":"The client-installer makes additional platform specific changes upon installation:","title":"3.2 Additional Changes"},{"location":"application/client/#321-windows","text":"","title":"3.2.1 Windows"},{"location":"application/client/#322-linux","text":"","title":"3.2.2 Linux"},{"location":"application/client/#323-mac-os","text":"","title":"3.2.3 Mac OS"},{"location":"application/client/#installer-flags","text":"Property Default Description path user.home + /.sandpolis The base installation path components null The components to install version latest The version to install ext.linux.desktop /usr/share/applications; user.home + /.local/share/applications The Linux desktop entry location ext.windows.start C:/ProgramData/Microsoft/Windows/Start Menu/Programs; user.home + /AppData/Microsoft/Windows/Start Menu/Programs The Windows start menu location ext.windows.desktop user.home + /Desktop The Windows desktop shortcut location","title":"Installer Flags"},{"location":"application/data_model/","text":"Data Model The data model is likely the single most important component of the entire project. Sandpolis plugins and modules depend on a generic and stable data model for many tasks. There are three layers in the Sandpolis data model. Of which, viewer applications are required to support at least two (ST and OID). The ST Layer The State Tree layer is the lowest layer and is concerned with storage and optionally persistence. Every Sandpolis instance maintains a global tree called the \"ST Tree\". The tree is seldomly manipulated directly by client code. Instead, the VST or OID layers make changes to the ST Tree on behalf of consumers. Attributes Attributes contain data of a specific type and meaning. All data in Sandpolis is stored in attributes. The history of an attribute can optionally be recorded. Use caution when using tracked attributes that are very large or change very frequently because they can quickly inflate the database. EphemeralAttribute HibernateAttribute EntangledAttribute Documents Documents are primarily a set of attributes, but can also have sub-documents or sub-collections. Collections Collections are sets of documents. Collections cannot have sub-attributes or sub-collections. Entanglement A special concept that exists in the ST layer is entanglement : sub-trees that reside on remote instances can synchronize their state. The relation can be bidirectional or unidirectional and last as long as necessary. All changes to the source of an entanglement pair will be propagated to the destination via a combination of ProtoCollection , ProtoDocument , and ProtoAttribute objects. The VST Layer The Virtual State Tree is parallel to the ST Tree and provides a user-friendly API to consumers. Classes in the VST layer are automatically generated by the codegen plugin according to a declarative state.json file in the module's root directory. The OID Layer Every node in a (V)ST Tree is uniquely identified by an OID. OIDs have a sequence of 64-bit integers that describe how to reach the corresponding node from the root node and a 64-bit namespace identifier that identifies the plugin or module to which the OID belongs. OIDs may define their parent as an OID from another module, so the namespace identifier prevents conflicts in the main sequence.","title":"Data Model"},{"location":"application/data_model/#data-model","text":"The data model is likely the single most important component of the entire project. Sandpolis plugins and modules depend on a generic and stable data model for many tasks. There are three layers in the Sandpolis data model. Of which, viewer applications are required to support at least two (ST and OID).","title":"Data Model"},{"location":"application/data_model/#the-st-layer","text":"The State Tree layer is the lowest layer and is concerned with storage and optionally persistence. Every Sandpolis instance maintains a global tree called the \"ST Tree\". The tree is seldomly manipulated directly by client code. Instead, the VST or OID layers make changes to the ST Tree on behalf of consumers.","title":"The ST Layer"},{"location":"application/data_model/#attributes","text":"Attributes contain data of a specific type and meaning. All data in Sandpolis is stored in attributes. The history of an attribute can optionally be recorded. Use caution when using tracked attributes that are very large or change very frequently because they can quickly inflate the database.","title":"Attributes"},{"location":"application/data_model/#ephemeralattribute","text":"","title":"EphemeralAttribute"},{"location":"application/data_model/#hibernateattribute","text":"","title":"HibernateAttribute"},{"location":"application/data_model/#entangledattribute","text":"","title":"EntangledAttribute"},{"location":"application/data_model/#documents","text":"Documents are primarily a set of attributes, but can also have sub-documents or sub-collections.","title":"Documents"},{"location":"application/data_model/#collections","text":"Collections are sets of documents. Collections cannot have sub-attributes or sub-collections.","title":"Collections"},{"location":"application/data_model/#entanglement","text":"A special concept that exists in the ST layer is entanglement : sub-trees that reside on remote instances can synchronize their state. The relation can be bidirectional or unidirectional and last as long as necessary. All changes to the source of an entanglement pair will be propagated to the destination via a combination of ProtoCollection , ProtoDocument , and ProtoAttribute objects.","title":"Entanglement"},{"location":"application/data_model/#the-vst-layer","text":"The Virtual State Tree is parallel to the ST Tree and provides a user-friendly API to consumers. Classes in the VST layer are automatically generated by the codegen plugin according to a declarative state.json file in the module's root directory.","title":"The VST Layer"},{"location":"application/data_model/#the-oid-layer","text":"Every node in a (V)ST Tree is uniquely identified by an OID. OIDs have a sequence of 64-bit integers that describe how to reach the corresponding node from the root node and a 64-bit namespace identifier that identifies the plugin or module to which the OID belongs. OIDs may define their parent as an OID from another module, so the namespace identifier prevents conflicts in the main sequence.","title":"The OID Layer"},{"location":"application/network/","text":"Sandpolis Protocol Sandpolis uses a custom binary protocol for all network communications that runs on TCP port 8768 by default. The Sandpolis protocol uses protocol buffers extensively which allows it to be fast, flexible, and language independent. Most communication happens over TCP connections among instances and the server, but Sandpolis can also coordinate direct TCP or UDP \"sessions\" between any two instances that need to transfer real-time data. Streams Many Sandpolis operations require real-time data for a short-lived or long-lived session. This is accomplished with the concept of a stream. All streams have a \"source\" and a \"sink\" and can exist between any two instances (a stream where the source and sink reside on the same instance is called a local stream ). The source's purpose is to produce stream events at whatever frequency is appropriate for the use-case and the sink's purpose is to consume those stream events. Multicasting Stream sources can push events to more than one sink simultaneously. This is called stream multicasting and saves bandwidth when multiple users request the same resource at the same time.","title":"Networking"},{"location":"application/network/#sandpolis-protocol","text":"Sandpolis uses a custom binary protocol for all network communications that runs on TCP port 8768 by default. The Sandpolis protocol uses protocol buffers extensively which allows it to be fast, flexible, and language independent. Most communication happens over TCP connections among instances and the server, but Sandpolis can also coordinate direct TCP or UDP \"sessions\" between any two instances that need to transfer real-time data.","title":"Sandpolis Protocol"},{"location":"application/network/#streams","text":"Many Sandpolis operations require real-time data for a short-lived or long-lived session. This is accomplished with the concept of a stream. All streams have a \"source\" and a \"sink\" and can exist between any two instances (a stream where the source and sink reside on the same instance is called a local stream ). The source's purpose is to produce stream events at whatever frequency is appropriate for the use-case and the sink's purpose is to consume those stream events.","title":"Streams"},{"location":"application/network/#multicasting","text":"Stream sources can push events to more than one sink simultaneously. This is called stream multicasting and saves bandwidth when multiple users request the same resource at the same time.","title":"Multicasting"},{"location":"application/server/","text":"Server Port The official port for the Sandpolis server is 8768 . Geolocation Services Sandpolis is able to get its location information from several sources, but the server can only use one service at a time. To choose a service, set the following system properties: Property Default Description server.geolocation.service ip-api.com The name of the geolocation service to use. Valid values are found in the table below. server.geolocation.key null The service API key server.geolocation.expiration 240 The cache timeout in hours The following public geolocation services are supported: Service Identifier ip-api.com ip-api.com tools.keycdn.com keycdn.com Permissions Since multiple clients can connect to a particular server at the same time, it's nice to have a permissions system to restrict a user's power. In most cases, a single admin client is sufficient for managing Sandpolis. Some advanced use cases require multiple users, which are feasible thanks to the permissions system. The user permissions system is similar to the MySQL permissions system. Permissions are \"granted\" to users by the admin upon user creation. These permissions dictate what a user can do on the server. New users have no permissions by default and therefore can do essentially nothing on the server. Permissions list Permission Description server.generate Rights to use the generator server.fs.read Read access to the server's filesystem server.fs.write Write access to the server's filesystem server.users.view Right to view usernames and permissions of all other users server.users.create Right to create new users (of lesser or equal permissions) server.state.stop Right to stop the server server.state.shutdown Right to shutdown the server server.state.restart Right to restart the server server.net.view Right to open the network control panel server.net.create_listener Right to create a new listener on the server server.auth.create_group Right to create a new authentication group on the server client.fs.read Read access to the client's filesystem client.fs.write Write access to the client's filesystem client.state.shutdown Right to shutdown the client client.state.restart Right to restart the client Authentication Groups Authentication groups solve two problems: they ensure clients connect to the correct server they conveniently partition clients so permissions can be easily enforced Since clients are dynamic, enforcing client.* permissions is more complicated than enforcing server.* permissions. This is because the subject of a client.* permission varies with context while a server.* permission always refers to the only server in the network. Generators Sandpolis is compatible with many different platforms and therefore needs to have a flexible approach to client installation. A Generator is a routine which produces some installation artifact according to a supplied configuration ( GenConfig ). This installation artifact is then used to install the Sandpolis client on a remote system. Installation Artifacts At minimum, installation artifacts contain configuration and settings for the client. Usually, installation artifacts will also contain the actual client code and be runnable on the remote system. Installers An installer contains the full client codebase and is runnable on the remote system. Upon execution, the installer sets up the base directory according to its configuration and executes the client. If the target directory already contains an installation, the old installation is overwritten. In an automated upgrade scenario, this operation poses no risk to data stored in the old client's database because this data would have been already flushed to the server. A manual upgrade could destroy data cached in the client database and is therefore not recommended. Advantages Simple Does not require Internet access during installation Disadvantages File size is large File transfer may be inconvenient Examples Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...) Downloaders Downloaders are similar to installers except dependencies must be downloaded upon execution. This can drastically reduce the size of the resulting installation artifact. Remote dependencies must be located in a Maven repository and not downloaded from the Sandpolis server. Advantages Smaller file size Disadvantages Requires Internet access during installation File transfer may be inconvenient Examples Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...) Tokens A token is an artifact which only contains the client configuration and cannot be executed by itself. When provided to a generic installer, the token allows the client to be installed on the remote system. Advantages No files are transferred Disadvantages More user interaction is required Examples Barcodes for use on Android, IOS, etc... Generators All installation artifacts are first generated on the server using a generator and then transferred to the requesting client (or client in the case of an automated upgrade). Generator Queue Since performing a generation is an infrequent task, the server maintains a simple queue of requests (generation configs) and fufills them serially. If the queue becomes full, incoming requests are dropped. Generator Configs A GenConfig specifies what type of generator should process it, any necessary options for that generator, and where to direct the resulting installation artifact. GenConfigs are implicitly created on the client from the graphical interface. 2 Server Server installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of an agent or client installation. 2.1 Filesystem Structure /base/server.jar The server executable. /base/server.db The server's only database. /base/lib A directory for extracted libraries, regardless of instance prerequisites. jar Contains platform-independent Java libraries. win Contains Windows-specific native libraries. lin Contains Linux-specific native libraries. osx Contains OSX-specific native libraries. bsd Contains BSD-specific native libraries. sol Contains Solaris-specific native libraries. /base/tmp A secondary temporary directory. 2.2 Additional Changes The server-installer makes additional platform specific changes upon installation: 2.2.1 Windows TODO: Research services 2.2.2 Linux 2.2.2.1 Systemd Management via systemd is supported. 2.2.3 Mac OS","title":"Server"},{"location":"application/server/#server-port","text":"The official port for the Sandpolis server is 8768 .","title":"Server Port"},{"location":"application/server/#geolocation-services","text":"Sandpolis is able to get its location information from several sources, but the server can only use one service at a time. To choose a service, set the following system properties: Property Default Description server.geolocation.service ip-api.com The name of the geolocation service to use. Valid values are found in the table below. server.geolocation.key null The service API key server.geolocation.expiration 240 The cache timeout in hours The following public geolocation services are supported: Service Identifier ip-api.com ip-api.com tools.keycdn.com keycdn.com","title":"Geolocation Services"},{"location":"application/server/#permissions","text":"Since multiple clients can connect to a particular server at the same time, it's nice to have a permissions system to restrict a user's power. In most cases, a single admin client is sufficient for managing Sandpolis. Some advanced use cases require multiple users, which are feasible thanks to the permissions system. The user permissions system is similar to the MySQL permissions system. Permissions are \"granted\" to users by the admin upon user creation. These permissions dictate what a user can do on the server. New users have no permissions by default and therefore can do essentially nothing on the server.","title":"Permissions"},{"location":"application/server/#permissions-list","text":"Permission Description server.generate Rights to use the generator server.fs.read Read access to the server's filesystem server.fs.write Write access to the server's filesystem server.users.view Right to view usernames and permissions of all other users server.users.create Right to create new users (of lesser or equal permissions) server.state.stop Right to stop the server server.state.shutdown Right to shutdown the server server.state.restart Right to restart the server server.net.view Right to open the network control panel server.net.create_listener Right to create a new listener on the server server.auth.create_group Right to create a new authentication group on the server client.fs.read Read access to the client's filesystem client.fs.write Write access to the client's filesystem client.state.shutdown Right to shutdown the client client.state.restart Right to restart the client","title":"Permissions list"},{"location":"application/server/#authentication-groups","text":"Authentication groups solve two problems: they ensure clients connect to the correct server they conveniently partition clients so permissions can be easily enforced Since clients are dynamic, enforcing client.* permissions is more complicated than enforcing server.* permissions. This is because the subject of a client.* permission varies with context while a server.* permission always refers to the only server in the network.","title":"Authentication Groups"},{"location":"application/server/#generators","text":"Sandpolis is compatible with many different platforms and therefore needs to have a flexible approach to client installation. A Generator is a routine which produces some installation artifact according to a supplied configuration ( GenConfig ). This installation artifact is then used to install the Sandpolis client on a remote system.","title":"Generators"},{"location":"application/server/#installation-artifacts","text":"At minimum, installation artifacts contain configuration and settings for the client. Usually, installation artifacts will also contain the actual client code and be runnable on the remote system.","title":"Installation Artifacts"},{"location":"application/server/#installers","text":"An installer contains the full client codebase and is runnable on the remote system. Upon execution, the installer sets up the base directory according to its configuration and executes the client. If the target directory already contains an installation, the old installation is overwritten. In an automated upgrade scenario, this operation poses no risk to data stored in the old client's database because this data would have been already flushed to the server. A manual upgrade could destroy data cached in the client database and is therefore not recommended.","title":"Installers"},{"location":"application/server/#advantages","text":"Simple Does not require Internet access during installation","title":"Advantages"},{"location":"application/server/#disadvantages","text":"File size is large File transfer may be inconvenient","title":"Disadvantages"},{"location":"application/server/#examples","text":"Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...)","title":"Examples"},{"location":"application/server/#downloaders","text":"Downloaders are similar to installers except dependencies must be downloaded upon execution. This can drastically reduce the size of the resulting installation artifact. Remote dependencies must be located in a Maven repository and not downloaded from the Sandpolis server.","title":"Downloaders"},{"location":"application/server/#advantages_1","text":"Smaller file size","title":"Advantages"},{"location":"application/server/#disadvantages_1","text":"Requires Internet access during installation File transfer may be inconvenient","title":"Disadvantages"},{"location":"application/server/#examples_1","text":"Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...)","title":"Examples"},{"location":"application/server/#tokens","text":"A token is an artifact which only contains the client configuration and cannot be executed by itself. When provided to a generic installer, the token allows the client to be installed on the remote system.","title":"Tokens"},{"location":"application/server/#advantages_2","text":"No files are transferred","title":"Advantages"},{"location":"application/server/#disadvantages_2","text":"More user interaction is required","title":"Disadvantages"},{"location":"application/server/#examples_2","text":"Barcodes for use on Android, IOS, etc...","title":"Examples"},{"location":"application/server/#generators_1","text":"All installation artifacts are first generated on the server using a generator and then transferred to the requesting client (or client in the case of an automated upgrade).","title":"Generators"},{"location":"application/server/#generator-queue","text":"Since performing a generation is an infrequent task, the server maintains a simple queue of requests (generation configs) and fufills them serially. If the queue becomes full, incoming requests are dropped.","title":"Generator Queue"},{"location":"application/server/#generator-configs","text":"A GenConfig specifies what type of generator should process it, any necessary options for that generator, and where to direct the resulting installation artifact. GenConfigs are implicitly created on the client from the graphical interface.","title":"Generator Configs"},{"location":"application/server/#2-server","text":"Server installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of an agent or client installation.","title":"2 Server"},{"location":"application/server/#21-filesystem-structure","text":"/base/server.jar The server executable. /base/server.db The server's only database. /base/lib A directory for extracted libraries, regardless of instance prerequisites. jar Contains platform-independent Java libraries. win Contains Windows-specific native libraries. lin Contains Linux-specific native libraries. osx Contains OSX-specific native libraries. bsd Contains BSD-specific native libraries. sol Contains Solaris-specific native libraries. /base/tmp A secondary temporary directory.","title":"2.1 Filesystem Structure"},{"location":"application/server/#22-additional-changes","text":"The server-installer makes additional platform specific changes upon installation:","title":"2.2 Additional Changes"},{"location":"application/server/#221-windows","text":"TODO: Research services","title":"2.2.1 Windows"},{"location":"application/server/#222-linux","text":"","title":"2.2.2 Linux"},{"location":"application/server/#2221-systemd","text":"Management via systemd is supported.","title":"2.2.2.1 Systemd"},{"location":"application/server/#223-mac-os","text":"","title":"2.2.3 Mac OS"},{"location":"tutorials/getting_started/","text":"Installing the Server The first thing you need to run Sandpolis is the server. There are several different ways to install the server. The universal installer will work on just about every system, but a specialized distribution package may be a more convenient option if your system supports it. With the universal installer GUI Download the universal installer for your operating system. Note Although the server runs on any platform, it's extremely convenient to manage the server process with systemctl on Linux. Select server from the available components and choose \"install\". With a distribution package Pacman (Arch Linux) Download either the stable or development package from the AUR: # Stable wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis.tar.gz # Development wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis-git.tar.gz Install with makepkg : tar xf sandpolis.tar.gz cd sandpolis makepkg -sif Start and optionally enable the server's systemd service unit: # Start the server process sudo systemctl start sandpolisd.service # Configure the server to start on boot sudo systemctl enable sandpolisd.service With Docker The server can also be run as a Docker container with the following command: sudo docker run --restart unless-stopped sandpolis/sandpolis-server:latest If your container isn't starting on boot, ensure the Docker daemon is configured to start automatically: sudo systemctl enable docker Installing a Client There are several official client applications that can be used to connect to a server. Not all of them have the same capabilities, so choose the variant that meets your needs. Sandpolis for iOS The Sandpolis iOS application can be installed from the App Store and supports iPhone and iPad devices running iOS 13.0 or greater. Warning The iOS app optionally uses Google's Firebase platform for user authentication. If you want to avoid Google's tracking, just login to your servers manually without creating an account. Create an account Your account allows you to save multiple servers for easy access and enables several features not possible with other client applications. Sandpolis Android application Coming soon... Sandpolis Desktop Client Coming soon... Installing the Agent With the universal installer GUI If you have the mobile application, you can scan the QR code in the universal installer to automatically associate the agent with the correct server. Generate an agent installer The desktop client can generate customized installers that can be used to install the agent on any machine.","title":"Getting Started"},{"location":"tutorials/getting_started/#installing-the-server","text":"The first thing you need to run Sandpolis is the server. There are several different ways to install the server. The universal installer will work on just about every system, but a specialized distribution package may be a more convenient option if your system supports it.","title":"Installing the Server"},{"location":"tutorials/getting_started/#with-the-universal-installer-gui","text":"Download the universal installer for your operating system. Note Although the server runs on any platform, it's extremely convenient to manage the server process with systemctl on Linux. Select server from the available components and choose \"install\".","title":"With the universal installer GUI"},{"location":"tutorials/getting_started/#with-a-distribution-package","text":"","title":"With a distribution package"},{"location":"tutorials/getting_started/#pacman-arch-linux","text":"Download either the stable or development package from the AUR: # Stable wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis.tar.gz # Development wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis-git.tar.gz Install with makepkg : tar xf sandpolis.tar.gz cd sandpolis makepkg -sif Start and optionally enable the server's systemd service unit: # Start the server process sudo systemctl start sandpolisd.service # Configure the server to start on boot sudo systemctl enable sandpolisd.service","title":"Pacman (Arch Linux)"},{"location":"tutorials/getting_started/#with-docker","text":"The server can also be run as a Docker container with the following command: sudo docker run --restart unless-stopped sandpolis/sandpolis-server:latest If your container isn't starting on boot, ensure the Docker daemon is configured to start automatically: sudo systemctl enable docker","title":"With Docker"},{"location":"tutorials/getting_started/#installing-a-client","text":"There are several official client applications that can be used to connect to a server. Not all of them have the same capabilities, so choose the variant that meets your needs.","title":"Installing a Client"},{"location":"tutorials/getting_started/#sandpolis-for-ios","text":"The Sandpolis iOS application can be installed from the App Store and supports iPhone and iPad devices running iOS 13.0 or greater. Warning The iOS app optionally uses Google's Firebase platform for user authentication. If you want to avoid Google's tracking, just login to your servers manually without creating an account.","title":"Sandpolis for iOS"},{"location":"tutorials/getting_started/#create-an-account","text":"Your account allows you to save multiple servers for easy access and enables several features not possible with other client applications.","title":"Create an account"},{"location":"tutorials/getting_started/#sandpolis-android-application","text":"Coming soon...","title":"Sandpolis Android application"},{"location":"tutorials/getting_started/#sandpolis-desktop-client","text":"Coming soon...","title":"Sandpolis Desktop Client"},{"location":"tutorials/getting_started/#installing-the-agent","text":"","title":"Installing the Agent"},{"location":"tutorials/getting_started/#with-the-universal-installer-gui_1","text":"If you have the mobile application, you can scan the QR code in the universal installer to automatically associate the agent with the correct server.","title":"With the universal installer GUI"},{"location":"tutorials/getting_started/#generate-an-agent-installer","text":"The desktop client can generate customized installers that can be used to install the agent on any machine.","title":"Generate an agent installer"},{"location":"tutorials/client/gui/","text":"Sandpolis Desktop Interface The desktop application is a fully-featured GUI that runs on Windows, Linux, and macOS.","title":"Desktop client"},{"location":"tutorials/client/gui/#sandpolis-desktop-interface","text":"The desktop application is a fully-featured GUI that runs on Windows, Linux, and macOS.","title":"Sandpolis Desktop Interface"},{"location":"tutorials/client/ios/","text":"","title":"Ios"},{"location":"tutorials/client/terminal/","text":"Terminal Interface Sandpolis comes with a minimalist text interface compatible with most ANSI-compliant terminals. It doesn't have as many features as the GUI, but it's fast and easy to use. As an added benefit, you'll look like a l33t h@ck3r when using it. Installation Starting a Listener Generating an Installer Address Port Timeout Path","title":"Terminal client"},{"location":"tutorials/client/terminal/#terminal-interface","text":"Sandpolis comes with a minimalist text interface compatible with most ANSI-compliant terminals. It doesn't have as many features as the GUI, but it's fast and easy to use. As an added benefit, you'll look like a l33t h@ck3r when using it.","title":"Terminal Interface"},{"location":"tutorials/client/terminal/#installation","text":"","title":"Installation"},{"location":"tutorials/client/terminal/#starting-a-listener","text":"","title":"Starting a Listener"},{"location":"tutorials/client/terminal/#generating-an-installer","text":"","title":"Generating an Installer"},{"location":"tutorials/client/terminal/#address","text":"","title":"Address"},{"location":"tutorials/client/terminal/#port","text":"","title":"Port"},{"location":"tutorials/client/terminal/#timeout","text":"","title":"Timeout"},{"location":"tutorials/client/terminal/#path","text":"","title":"Path"}]}