{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sandpolis Official Documentation This site explains how to install , configure , and maintain Sandpolis. It's still a work in progress; feel free to open an issue . The Basics You may already be familiar with other remote-control utilities that allow you to monitor/manage many different computers from a single pane of glass. To use these tools, you might install a stub or agent on the computers you wish to manage and direct that stub to connect back to the main application running on your computer. While relatively simple, there are some major disadvantages to this approach: Your computer may not always be online to accept connections Your computer may not have a stable IP address This architecture does not scale as the number of client computers increases To address these problems, Sandpolis uses a client-server-viewer (CSV) architecture. Rather than connecting clients directly to an application on your computer, a central server mediates most interactions between you and your client systems. Client <-> Server <-> Viewer With CSV, clients and viewers can come and go without affecting the rest of the network. This means that: background or scheduled tasks can continue after a user logs out; users are not restricted to a particular user interface; users don't have to adjust their firewalls or port-forwarding rules. CSV also comes with a few drawbacks: The server is just another application to maintain Although it can be easy to deploy with Docker, the server still requires some effort to maintain. In addition to the initial setup, it's important to periodically update the server for the next reason below. The server is a high value attack target While the server is designed to be as resilient and secure as possible, it can't be perfect. If an attacker is able to compromise the server (or a user account with sufficiently high privileges), they effectively have full control over all systems connected to the server. It's important to follow good security practices and password etiquette when running your own server. Messages between clients and viewers are usually routed through the server first Often times the route between a user and their clients will be faster than the user/server route plus the server/client route. This is especially true if a user is on the same network as their clients. To mitigate this issue, the server can automatically coordinate a direct connection between any two nodes for high-volume messages like remote desktop streams or file transfers.","title":"Home"},{"location":"#sandpolis-official-documentation","text":"This site explains how to install , configure , and maintain Sandpolis. It's still a work in progress; feel free to open an issue .","title":"Sandpolis Official Documentation"},{"location":"#the-basics","text":"You may already be familiar with other remote-control utilities that allow you to monitor/manage many different computers from a single pane of glass. To use these tools, you might install a stub or agent on the computers you wish to manage and direct that stub to connect back to the main application running on your computer. While relatively simple, there are some major disadvantages to this approach: Your computer may not always be online to accept connections Your computer may not have a stable IP address This architecture does not scale as the number of client computers increases To address these problems, Sandpolis uses a client-server-viewer (CSV) architecture. Rather than connecting clients directly to an application on your computer, a central server mediates most interactions between you and your client systems.","title":"The Basics"},{"location":"#client-server-viewer","text":"With CSV, clients and viewers can come and go without affecting the rest of the network. This means that: background or scheduled tasks can continue after a user logs out; users are not restricted to a particular user interface; users don't have to adjust their firewalls or port-forwarding rules. CSV also comes with a few drawbacks:","title":"Client &lt;-&gt; Server &lt;-&gt; Viewer"},{"location":"#the-server-is-just-another-application-to-maintain","text":"Although it can be easy to deploy with Docker, the server still requires some effort to maintain. In addition to the initial setup, it's important to periodically update the server for the next reason below.","title":"The server is just another application to maintain"},{"location":"#the-server-is-a-high-value-attack-target","text":"While the server is designed to be as resilient and secure as possible, it can't be perfect. If an attacker is able to compromise the server (or a user account with sufficiently high privileges), they effectively have full control over all systems connected to the server. It's important to follow good security practices and password etiquette when running your own server.","title":"The server is a high value attack target"},{"location":"#messages-between-clients-and-viewers-are-usually-routed-through-the-server-first","text":"Often times the route between a user and their clients will be faster than the user/server route plus the server/client route. This is especially true if a user is on the same network as their clients. To mitigate this issue, the server can automatically coordinate a direct connection between any two nodes for high-volume messages like remote desktop streams or file transfers.","title":"Messages between clients and viewers are usually routed through the server first"},{"location":"getting_started/","text":"Installing the Server There are several different ways to install the server. The universal installer will work on just about every system, but a specialized distribution package may be a more convenient option if your system supports it. With the universal installer GUI Download the universal installer for your operating system. Note Although the server runs on any platform, it's extremely convenient to manage the server process with systemctl on Linux. Select server from the available components and choose \"install\". With a distribution package Pacman (Arch Linux) Download either the stable or development package from the AUR: # Stable wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis.tar.gz # Development wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis-git.tar.gz Install with makepkg : tar xf sandpolis.tar.gz cd sandpolis makepkg -sif Start and optionally enable the server's systemd service unit: # Start the server process sudo systemctl start sandpolisd.service # Configure the server to start on boot sudo systemctl enable sandpolisd.service With Docker The server can also be run as a Docker container with the following command: sudo docker run --restart unless-stopped sandpolis/sandpolis-server:latest If your container isn't starting on boot, ensure the Docker daemon is configured to start automatically: sudo systemctl enable docker Installing the Viewer There are several official viewer applications that can be used to connect to a server. Not all of them have the same capabilities, so choose the variant that meets your needs. Sandpolis for iOS The Sandpolis iOS application can be installed from the App Store and supports iPhone and iPad devices running iOS 13.0 or greater. Warning The iOS app optionally uses Google's Firebase platform for user authentication. If you avoid Google products, just login to your servers manually without creating an account. Create an account Your account allows you to save multiple servers for easy access and enables several features not possible with other viewer applications. Sandpolis Android application Coming soon... Sandpolis Desktop Viewer Coming soon... Installing the Client With the universal installer GUI If you have the mobile application, you can scan the QR code in the universal installer to automatically associate the client with the correct server. Generate a client installer The desktop viewer can generate customized installers that can be used to install the client on any machine.","title":"Getting Started"},{"location":"getting_started/#installing-the-server","text":"There are several different ways to install the server. The universal installer will work on just about every system, but a specialized distribution package may be a more convenient option if your system supports it.","title":"Installing the Server"},{"location":"getting_started/#with-the-universal-installer-gui","text":"Download the universal installer for your operating system. Note Although the server runs on any platform, it's extremely convenient to manage the server process with systemctl on Linux. Select server from the available components and choose \"install\".","title":"With the universal installer GUI"},{"location":"getting_started/#with-a-distribution-package","text":"","title":"With a distribution package"},{"location":"getting_started/#pacman-arch-linux","text":"Download either the stable or development package from the AUR: # Stable wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis.tar.gz # Development wget https://aur.archlinux.org/cgit/aur.git/snapshot/sandpolis-git.tar.gz Install with makepkg : tar xf sandpolis.tar.gz cd sandpolis makepkg -sif Start and optionally enable the server's systemd service unit: # Start the server process sudo systemctl start sandpolisd.service # Configure the server to start on boot sudo systemctl enable sandpolisd.service","title":"Pacman (Arch Linux)"},{"location":"getting_started/#with-docker","text":"The server can also be run as a Docker container with the following command: sudo docker run --restart unless-stopped sandpolis/sandpolis-server:latest If your container isn't starting on boot, ensure the Docker daemon is configured to start automatically: sudo systemctl enable docker","title":"With Docker"},{"location":"getting_started/#installing-the-viewer","text":"There are several official viewer applications that can be used to connect to a server. Not all of them have the same capabilities, so choose the variant that meets your needs.","title":"Installing the Viewer"},{"location":"getting_started/#sandpolis-for-ios","text":"The Sandpolis iOS application can be installed from the App Store and supports iPhone and iPad devices running iOS 13.0 or greater. Warning The iOS app optionally uses Google's Firebase platform for user authentication. If you avoid Google products, just login to your servers manually without creating an account.","title":"Sandpolis for iOS"},{"location":"getting_started/#create-an-account","text":"Your account allows you to save multiple servers for easy access and enables several features not possible with other viewer applications.","title":"Create an account"},{"location":"getting_started/#sandpolis-android-application","text":"Coming soon...","title":"Sandpolis Android application"},{"location":"getting_started/#sandpolis-desktop-viewer","text":"Coming soon...","title":"Sandpolis Desktop Viewer"},{"location":"getting_started/#installing-the-client","text":"","title":"Installing the Client"},{"location":"getting_started/#with-the-universal-installer-gui_1","text":"If you have the mobile application, you can scan the QR code in the universal installer to automatically associate the client with the correct server.","title":"With the universal installer GUI"},{"location":"getting_started/#generate-a-client-installer","text":"The desktop viewer can generate customized installers that can be used to install the client on any machine.","title":"Generate a client installer"},{"location":"installation/","text":"1 Client Client installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of a server or viewer installation. 1.1 Filesystem Structure /base/client.jar The client executable, named according to the configuration. /base/client.db The client's only database, named according to the executable. /base/lib A directory for extracted client-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory. 1.2 Additional Changes The client-installer makes additional platform specific changes upon installation: 1.2.1 Windows 1.2.2 Linux 1.2.3 Mac OS 1.3 Upgrading There are two ways to upgrade the client: - automatically by sending the update command to the server, - manually by generating a new installer and executing it on the client 1.3.1 Manual Upgrade A manual upgrade is triggered when an installer is executed on the client and the relevant base directory is already populated with an installation. If the client is not running, the installer will overwrite the base directory and install itself. Any data that the client has cached but not sent to the server will be lost! Advantages - This is the only way to upgrade if the client can no longer connect to the server Disadvantages - Manual intervention required - Cached data may be lost 1.3.2 Automated Upgrade If the client is connected to a server, simply issue the update/upgrade command from a viewer instance. This will cause the server to fetch the client configuration, generate a new installer, and transfer it to the client. The client then executes the new installer and terminates. 2 Server Server installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of a client or viewer installation. 2.1 Filesystem Structure /base/server.jar The server executable. /base/server.db The server's only database. /base/lib A directory for extracted libraries, regardless of instance prerequisites. jar Contains platform-independent Java libraries. win Contains Windows-specific native libraries. lin Contains Linux-specific native libraries. osx Contains OSX-specific native libraries. bsd Contains BSD-specific native libraries. sol Contains Solaris-specific native libraries. /base/tmp A secondary temporary directory. 2.2 Additional Changes The server-installer makes additional platform specific changes upon installation: 2.2.1 Windows TODO: Research services 2.2.2 Linux 2.2.2.1 Systemd Management via systemd is supported. 2.2.3 Mac OS 3 Viewer Viewer installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of a client or server installation. 3.1 Filesystem Structure /base/viewer.jar The viewer executable. /base/viewer.ico An icon for the viewer /base/db A directory for viewer databases. Each server that the viewer connects to will have a corresponding database located here. /base/lib A directory for extracted viewer-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory. 3.2 Additional Changes The viewer-installer makes additional platform specific changes upon installation: 3.2.1 Windows 3.2.2 Linux 3.2.3 Mac OS Installer Flags Property Default Description path user.home + /.sandpolis The base installation path components null The components to install version latest The version to install ext.linux.desktop /usr/share/applications; user.home + /.local/share/applications The Linux desktop entry location ext.windows.start C:/ProgramData/Microsoft/Windows/Start Menu/Programs; user.home + /AppData/Microsoft/Windows/Start Menu/Programs The Windows start menu location ext.windows.desktop user.home + /Desktop The Windows desktop shortcut location","title":"Installation"},{"location":"installation/#1-client","text":"Client installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of a server or viewer installation.","title":"1 Client"},{"location":"installation/#11-filesystem-structure","text":"/base/client.jar The client executable, named according to the configuration. /base/client.db The client's only database, named according to the executable. /base/lib A directory for extracted client-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory.","title":"1.1 Filesystem Structure"},{"location":"installation/#12-additional-changes","text":"The client-installer makes additional platform specific changes upon installation:","title":"1.2 Additional Changes"},{"location":"installation/#121-windows","text":"","title":"1.2.1 Windows"},{"location":"installation/#122-linux","text":"","title":"1.2.2 Linux"},{"location":"installation/#123-mac-os","text":"","title":"1.2.3 Mac OS"},{"location":"installation/#13-upgrading","text":"There are two ways to upgrade the client: - automatically by sending the update command to the server, - manually by generating a new installer and executing it on the client","title":"1.3 Upgrading"},{"location":"installation/#131-manual-upgrade","text":"A manual upgrade is triggered when an installer is executed on the client and the relevant base directory is already populated with an installation. If the client is not running, the installer will overwrite the base directory and install itself. Any data that the client has cached but not sent to the server will be lost! Advantages - This is the only way to upgrade if the client can no longer connect to the server Disadvantages - Manual intervention required - Cached data may be lost","title":"1.3.1 Manual Upgrade"},{"location":"installation/#132-automated-upgrade","text":"If the client is connected to a server, simply issue the update/upgrade command from a viewer instance. This will cause the server to fetch the client configuration, generate a new installer, and transfer it to the client. The client then executes the new installer and terminates.","title":"1.3.2 Automated Upgrade"},{"location":"installation/#2-server","text":"Server installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of a client or viewer installation.","title":"2 Server"},{"location":"installation/#21-filesystem-structure","text":"/base/server.jar The server executable. /base/server.db The server's only database. /base/lib A directory for extracted libraries, regardless of instance prerequisites. jar Contains platform-independent Java libraries. win Contains Windows-specific native libraries. lin Contains Linux-specific native libraries. osx Contains OSX-specific native libraries. bsd Contains BSD-specific native libraries. sol Contains Solaris-specific native libraries. /base/tmp A secondary temporary directory.","title":"2.1 Filesystem Structure"},{"location":"installation/#22-additional-changes","text":"The server-installer makes additional platform specific changes upon installation:","title":"2.2 Additional Changes"},{"location":"installation/#221-windows","text":"TODO: Research services","title":"2.2.1 Windows"},{"location":"installation/#222-linux","text":"","title":"2.2.2 Linux"},{"location":"installation/#2221-systemd","text":"Management via systemd is supported.","title":"2.2.2.1 Systemd"},{"location":"installation/#223-mac-os","text":"","title":"2.2.3 Mac OS"},{"location":"installation/#3-viewer","text":"Viewer installations are entirely contained in a single directory called the base directory. This base directory may not coincide with the base directory of a client or server installation.","title":"3 Viewer"},{"location":"installation/#31-filesystem-structure","text":"/base/viewer.jar The viewer executable. /base/viewer.ico An icon for the viewer /base/db A directory for viewer databases. Each server that the viewer connects to will have a corresponding database located here. /base/lib A directory for extracted viewer-libraries. For simplicity, all libraries, native and multiplatform, are located in the root of this directory. /base/tmp A secondary temporary directory.","title":"3.1 Filesystem Structure"},{"location":"installation/#32-additional-changes","text":"The viewer-installer makes additional platform specific changes upon installation:","title":"3.2 Additional Changes"},{"location":"installation/#321-windows","text":"","title":"3.2.1 Windows"},{"location":"installation/#322-linux","text":"","title":"3.2.2 Linux"},{"location":"installation/#323-mac-os","text":"","title":"3.2.3 Mac OS"},{"location":"installation/#installer-flags","text":"Property Default Description path user.home + /.sandpolis The base installation path components null The components to install version latest The version to install ext.linux.desktop /usr/share/applications; user.home + /.local/share/applications The Linux desktop entry location ext.windows.start C:/ProgramData/Microsoft/Windows/Start Menu/Programs; user.home + /AppData/Microsoft/Windows/Start Menu/Programs The Windows start menu location ext.windows.desktop user.home + /Desktop The Windows desktop shortcut location","title":"Installer Flags"},{"location":"server/","text":"Server Port The official port for the Sandpolis server is 8768 . Geolocation Services Sandpolis is able to get its location information from several sources, but the server can only use one service at a time. To choose a service, set the following system properties: Property Default Description server.geolocation.service ip-api.com The name of the geolocation service to use. Valid values are found in the table below. server.geolocation.key null The service API key server.geolocation.expiration 240 The cache timeout in hours The following public geolocation services are supported: Service Identifier ip-api.com ip-api.com tools.keycdn.com keycdn.com Permissions Since multiple viewers can connect to a particular server at the same time, it's nice to have a permissions system to restrict a user's power. In most cases, a single admin viewer is sufficient for managing Sandpolis. Some advanced use cases require multiple users, which are feasible thanks to the permissions system. The user permissions system is similar to the MySQL permissions system. Permissions are \"granted\" to users by the admin upon user creation. These permissions dictate what a user can do on the server. New users have no permissions by default and therefore can do essentially nothing on the server. Permissions list Permission Description server.generate Rights to use the generator server.fs.read Read access to the server's filesystem server.fs.write Write access to the server's filesystem server.users.view Right to view usernames and permissions of all other users server.users.create Right to create new users (of lesser or equal permissions) server.state.stop Right to stop the server server.state.shutdown Right to shutdown the server server.state.restart Right to restart the server server.net.view Right to open the network control panel server.net.create_listener Right to create a new listener on the server server.auth.create_group Right to create a new authentication group on the server client.fs.read Read access to the client's filesystem client.fs.write Write access to the client's filesystem client.state.shutdown Right to shutdown the client client.state.restart Right to restart the client Authentication Groups Authentication groups solve two problems: they ensure clients connect to the correct server they conveniently partition clients so permissions can be easily enforced Since clients are dynamic, enforcing client.* permissions is more complicated than enforcing server.* permissions. This is because the subject of a client.* permission varies with context while a server.* permission always refers to the only server in the network. Generators Sandpolis is compatible with many different platforms and therefore needs to have a flexible approach to client installation. A Generator is a routine which produces some installation artifact according to a supplied configuration ( GenConfig ). This installation artifact is then used to install the Sandpolis client on a remote system. Installation Artifacts At minimum, installation artifacts contain configuration and settings for the client. Usually, installation artifacts will also contain the actual client code and be runnable on the remote system. Installers An installer contains the full client codebase and is runnable on the remote system. Upon execution, the installer sets up the base directory according to its configuration and executes the client. If the target directory already contains an installation, the old installation is overwritten. In an automated upgrade scenario, this operation poses no risk to data stored in the old client's database because this data would have been already flushed to the server. A manual upgrade could destroy data cached in the client database and is therefore not recommended. Advantages Simple Does not require Internet access during installation Disadvantages File size is large File transfer may be inconvenient Examples Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...) Downloaders Downloaders are similar to installers except dependencies must be downloaded upon execution. This can drastically reduce the size of the resulting installation artifact. Remote dependencies must be located in a Maven repository and not downloaded from the Sandpolis server. Advantages Smaller file size Disadvantages Requires Internet access during installation File transfer may be inconvenient Examples Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...) Tokens A token is an artifact which only contains the client configuration and cannot be executed by itself. When provided to a generic installer, the token allows the client to be installed on the remote system. Advantages No files are transferred Disadvantages More user interaction is required Examples Barcodes for use on Android, IOS, etc... Generators All installation artifacts are first generated on the server using a generator and then transferred to the requesting viewer (or client in the case of an automated upgrade). Generator Queue Since performing a generation is an infrequent task, the server maintains a simple queue of requests (generation configs) and fufills them serially. If the queue becomes full, incoming requests are dropped. Generator Configs A GenConfig specifies what type of generator should process it, any necessary options for that generator, and where to direct the resulting installation artifact. GenConfigs are implicitly created on the viewer from the graphical interface.","title":"The Server"},{"location":"server/#server-port","text":"The official port for the Sandpolis server is 8768 .","title":"Server Port"},{"location":"server/#geolocation-services","text":"Sandpolis is able to get its location information from several sources, but the server can only use one service at a time. To choose a service, set the following system properties: Property Default Description server.geolocation.service ip-api.com The name of the geolocation service to use. Valid values are found in the table below. server.geolocation.key null The service API key server.geolocation.expiration 240 The cache timeout in hours The following public geolocation services are supported: Service Identifier ip-api.com ip-api.com tools.keycdn.com keycdn.com","title":"Geolocation Services"},{"location":"server/#permissions","text":"Since multiple viewers can connect to a particular server at the same time, it's nice to have a permissions system to restrict a user's power. In most cases, a single admin viewer is sufficient for managing Sandpolis. Some advanced use cases require multiple users, which are feasible thanks to the permissions system. The user permissions system is similar to the MySQL permissions system. Permissions are \"granted\" to users by the admin upon user creation. These permissions dictate what a user can do on the server. New users have no permissions by default and therefore can do essentially nothing on the server.","title":"Permissions"},{"location":"server/#permissions-list","text":"Permission Description server.generate Rights to use the generator server.fs.read Read access to the server's filesystem server.fs.write Write access to the server's filesystem server.users.view Right to view usernames and permissions of all other users server.users.create Right to create new users (of lesser or equal permissions) server.state.stop Right to stop the server server.state.shutdown Right to shutdown the server server.state.restart Right to restart the server server.net.view Right to open the network control panel server.net.create_listener Right to create a new listener on the server server.auth.create_group Right to create a new authentication group on the server client.fs.read Read access to the client's filesystem client.fs.write Write access to the client's filesystem client.state.shutdown Right to shutdown the client client.state.restart Right to restart the client","title":"Permissions list"},{"location":"server/#authentication-groups","text":"Authentication groups solve two problems: they ensure clients connect to the correct server they conveniently partition clients so permissions can be easily enforced Since clients are dynamic, enforcing client.* permissions is more complicated than enforcing server.* permissions. This is because the subject of a client.* permission varies with context while a server.* permission always refers to the only server in the network.","title":"Authentication Groups"},{"location":"server/#generators","text":"Sandpolis is compatible with many different platforms and therefore needs to have a flexible approach to client installation. A Generator is a routine which produces some installation artifact according to a supplied configuration ( GenConfig ). This installation artifact is then used to install the Sandpolis client on a remote system.","title":"Generators"},{"location":"server/#installation-artifacts","text":"At minimum, installation artifacts contain configuration and settings for the client. Usually, installation artifacts will also contain the actual client code and be runnable on the remote system.","title":"Installation Artifacts"},{"location":"server/#installers","text":"An installer contains the full client codebase and is runnable on the remote system. Upon execution, the installer sets up the base directory according to its configuration and executes the client. If the target directory already contains an installation, the old installation is overwritten. In an automated upgrade scenario, this operation poses no risk to data stored in the old client's database because this data would have been already flushed to the server. A manual upgrade could destroy data cached in the client database and is therefore not recommended.","title":"Installers"},{"location":"server/#advantages","text":"Simple Does not require Internet access during installation","title":"Advantages"},{"location":"server/#disadvantages","text":"File size is large File transfer may be inconvenient","title":"Disadvantages"},{"location":"server/#examples","text":"Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...)","title":"Examples"},{"location":"server/#downloaders","text":"Downloaders are similar to installers except dependencies must be downloaded upon execution. This can drastically reduce the size of the resulting installation artifact. Remote dependencies must be located in a Maven repository and not downloaded from the Sandpolis server.","title":"Downloaders"},{"location":"server/#advantages_1","text":"Smaller file size","title":"Advantages"},{"location":"server/#disadvantages_1","text":"Requires Internet access during installation File transfer may be inconvenient","title":"Disadvantages"},{"location":"server/#examples_1","text":"Runnable Jar files (.jar, .war, .ear) Windows portable executables (.exe, .msi) Scripts (.sh, .rb, .py, .bat, ...)","title":"Examples"},{"location":"server/#tokens","text":"A token is an artifact which only contains the client configuration and cannot be executed by itself. When provided to a generic installer, the token allows the client to be installed on the remote system.","title":"Tokens"},{"location":"server/#advantages_2","text":"No files are transferred","title":"Advantages"},{"location":"server/#disadvantages_2","text":"More user interaction is required","title":"Disadvantages"},{"location":"server/#examples_2","text":"Barcodes for use on Android, IOS, etc...","title":"Examples"},{"location":"server/#generators_1","text":"All installation artifacts are first generated on the server using a generator and then transferred to the requesting viewer (or client in the case of an automated upgrade).","title":"Generators"},{"location":"server/#generator-queue","text":"Since performing a generation is an infrequent task, the server maintains a simple queue of requests (generation configs) and fufills them serially. If the queue becomes full, incoming requests are dropped.","title":"Generator Queue"},{"location":"server/#generator-configs","text":"A GenConfig specifies what type of generator should process it, any necessary options for that generator, and where to direct the resulting installation artifact. GenConfigs are implicitly created on the viewer from the graphical interface.","title":"Generator Configs"},{"location":"viewer/gui/","text":"Sandpolis Desktop Interface","title":"Desktop Viewer"},{"location":"viewer/gui/#sandpolis-desktop-interface","text":"","title":"Sandpolis Desktop Interface"},{"location":"viewer/terminal/","text":"Terminal Interface Sandpolis comes with a minimalist text interface compatible with most ANSI-compliant terminals. It doesn't have as many features as the GUI, but it's fast and easy to use. Installation Starting a Listener Generating an Installer Address Port Timeout Path","title":"Terminal Viewer"},{"location":"viewer/terminal/#terminal-interface","text":"Sandpolis comes with a minimalist text interface compatible with most ANSI-compliant terminals. It doesn't have as many features as the GUI, but it's fast and easy to use.","title":"Terminal Interface"},{"location":"viewer/terminal/#installation","text":"","title":"Installation"},{"location":"viewer/terminal/#starting-a-listener","text":"","title":"Starting a Listener"},{"location":"viewer/terminal/#generating-an-installer","text":"","title":"Generating an Installer"},{"location":"viewer/terminal/#address","text":"","title":"Address"},{"location":"viewer/terminal/#port","text":"","title":"Port"},{"location":"viewer/terminal/#timeout","text":"","title":"Timeout"},{"location":"viewer/terminal/#path","text":"","title":"Path"}]}