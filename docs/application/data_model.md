# Data Model
The data model is likely the single most important component of the entire project. Sandpolis plugins and modules depend on a generic and stable data model for many tasks.

There are three layers in the Sandpolis data model. Of which, viewer applications are required to support at least two (ST and OID).

## The ST Layer
The State Tree layer is the lowest layer and is concerned with storage and optionally persistence. Every Sandpolis instance maintains a global tree called the "ST Tree". The tree is seldomly manipulated directly by client code. Instead, the VST or OID layers make changes to the ST Tree on behalf of consumers.

### Attributes
Attributes contain data of a specific type and meaning. All data in Sandpolis is stored in attributes.

The history of an attribute can optionally be recorded. Use caution when using _tracked attributes_ that are very large or change very frequently because they can quickly inflate the database.

#### EphemeralAttribute

#### HibernateAttribute

#### EntangledAttribute

### Documents
Documents are primarily a set of attributes, but can also have sub-documents or sub-collections.

### Collections
Collections are sets of documents. Collections cannot have sub-attributes or sub-collections.

### Entanglement
A special concept that exists in the ST layer is **entanglement**: sub-trees that reside on remote instances can synchronize their state. The relation can be bidirectional or unidirectional and last as long as necessary. All changes to the source of an entanglement pair will be propagated to the destination via a combination of `ProtoCollection`, `ProtoDocument`, and `ProtoAttribute` objects.

## The VST Layer
The Virtual State Tree is parallel to the ST Tree and provides a user-friendly API to consumers. Classes in the VST layer are automatically generated by the codegen plugin according to a declarative `state.json` file in the module's root directory.

## The OID Layer
Every node in a (V)ST Tree is uniquely identified by an OID. OIDs have a sequence of 64-bit integers that describe how to reach the corresponding node from the root node and a 64-bit namespace identifier that identifies the plugin or module to which the OID belongs.

OIDs may define their parent as an OID from another module, so the namespace identifier prevents conflicts in the main sequence.
